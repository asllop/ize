//! # IZE Parser
//!
//! This module contains all the types and methods necessary to convert the list of tokens generated by the [lexer][crate::lexer] into an Abstract Syntax Tree.

use crate::lexer::{Line, Position, Token, TokenData, TokenType};
use alloc::{boxed::Box, collections::VecDeque, string::String, vec::Vec};
use core::fmt::Display;

#[derive(Debug)]
/// Parsing error.
pub struct ParserError {
    /// Error message.
    pub message: String,
    /// Offset within the line where the error happened.
    pub offset: usize,
}

//TODO: create an AST struct with a Vec<Expr>, and use indexes to this vec instead of Box<Expr> to reduce allocations.

#[derive(Debug)]
/// Expression.
pub enum Expr {
    Literal(Token),
    Identifier(Token),
    Group {
        expr: Box<Expr>,
    },
    UnaryOp {
        op: Token,
        child: Box<Expr>,
    },
    BinaryOp {
        op: Token,
        left_child: Box<Expr>,
        right_child: Box<Expr>,
    },
    Object {
        chain: Vec<Expr>,
    },
    Call {
        func: Token,
        args: Vec<Expr>,
    },
    Empty,
}

impl Display for Expr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Expr::Literal(t) => write!(f, "{}{}", t.token_type, t.data),
            Expr::Identifier(t) => write!(f, "{}{}", t.token_type, t.data),
            Expr::Group { expr } => write!(f, "[{}]", expr),
            Expr::UnaryOp { op, child } => write!(f, "({} {})", op.token_type, child),
            Expr::BinaryOp {
                op,
                left_child,
                right_child,
            } => write!(f, "({} {} , {})", op.token_type, left_child, right_child),
            Expr::Call { func, args } => {
                write!(f, "{}(", func.data).ok();
                for arg in args {
                    write!(f, "{} ; ", arg).ok();
                }
                write!(f, ")")
            }
            Expr::Object { chain } => {
                for link in chain {
                    write!(f, "{}.", link).ok();
                }
                Ok(())
            }
            Expr::Empty => write!(f, ""),
        }
    }
}

#[derive(Debug)]
/// Statement.
pub enum Stmt {
    VarDef { var_name: String, init: Expr },
    ConstDef { var_name: String, init: Expr },
    Print(Expr),
    Expr(Expr),
}

#[derive(Debug, Default)]
/// Abstract Syntax Tree.
pub struct Ast {
    pub statements: Vec<(usize, Stmt)>,
}

impl Ast {
    pub fn push(&mut self, line_num: usize, stmt: Stmt) {
        self.statements.push((line_num, stmt));
    }
}

#[derive(Debug)]
/// Parser for one line of code.
pub struct LineParser {
    pub tokens: VecDeque<Token>,
    pub position: Position,
}

impl LineParser {
    /// Parse line of code.
    pub fn parse(line: Line) -> Result<Stmt, ParserError> {
        let mut parser = Self {
            tokens: line.tokens.into(),
            position: line.position,
        };
        let stmt = parser.statement()?;
        if parser.is_at_end() {
            Ok(stmt)
        } else {
            Err(ParserError {
                message: "Couldn't parse a complete statement".into(),
                offset: 0,
            })
        }
    }

    /// Statement.
    fn statement(&mut self) -> Result<Stmt, ParserError> {
        if let Some(_) = self.match_token(&[TokenType::VarDefinition]) {
            self.var_def_statement()
        } else if let Some(_) = self.match_token(&[TokenType::ConstDefinition]) {
            self.const_def_statement()
        } else if let Some(_) = self.match_token(&[TokenType::Print]) {
            self.print_statement()
        } else {
            // Otherwise, expression statement
            self.expression_statement()
        }
    }

    /// Var def statement.
    fn var_def_statement(&mut self) -> Result<Stmt, ParserError> {
        if let Some(Token {
            data: TokenData::String(ident),
            offset,
            ..
        }) = self.match_token(&[TokenType::Identifier])
        {
            if let Some(_) = self.match_token(&[TokenType::Equal]) {
                let expr = self.expression()?;
                Ok(Stmt::VarDef {
                    var_name: ident,
                    init: expr,
                })
            } else {
                return Err(ParserError {
                    message: "Expected '=' after variable name".into(),
                    offset,
                });
            }
        } else {
            return Err(ParserError {
                message: "Expected variable name after 'var'".into(),
                offset: 0,
            });
        }
    }

    /// Const def statement.
    fn const_def_statement(&mut self) -> Result<Stmt, ParserError> {
        if let Some(Token {
            data: TokenData::String(ident),
            offset,
            ..
        }) = self.match_token(&[TokenType::Identifier])
        {
            if let Some(_) = self.match_token(&[TokenType::Equal]) {
                let expr = self.expression()?;
                Ok(Stmt::ConstDef {
                    var_name: ident,
                    init: expr,
                })
            } else {
                return Err(ParserError {
                    message: "Expected '=' after variable name".into(),
                    offset,
                });
            }
        } else {
            return Err(ParserError {
                message: "Expected variable name after 'var'".into(),
                offset: 0,
            });
        }
    }

    /// Print statement.
    fn print_statement(&mut self) -> Result<Stmt, ParserError> {
        let expr = self.expression()?;
        Ok(Stmt::Print(expr))
    }

    /// Any expression.
    fn expression_statement(&mut self) -> Result<Stmt, ParserError> {
        let expr = self.expression()?;
        Ok(Stmt::Expr(expr))
    }

    /// Any expression.
    fn expression(&mut self) -> Result<Expr, ParserError> {
        self.equality()
    }

    //TODO: assignments are statements, not expressions
    // (IDENTIFIER | OBJECT_CHAIN) "=" EXPRESSION
    /// Assignment.
    // fn assign(&mut self) -> Result<Expr, ParserError> {
    //     let mut expr: Expr = self.equality()?;
    //     //TODO: check if "expr" is either an identifier or an object
    //     while let Some(operator) = self.match_token(&[TokenType::Equal]) {
    //         let right = self.equality()?;
    //         expr = Expr::BinaryOp {
    //             op: operator,
    //             left_child: Box::new(expr),
    //             right_child: Box::new(right),
    //         };
    //     }
    //     Ok(expr)
    // }

    /// Equal and not equal.
    fn equality(&mut self) -> Result<Expr, ParserError> {
        let mut expr: Expr = self.comparison()?;
        while let Some(operator) = self.match_token(&[TokenType::TwoEquals, TokenType::NotEqual]) {
            let right = self.comparison()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    // Greather than, Lesser than, Gt or Equal, Lt or Equal, And, Or.
    fn comparison(&mut self) -> Result<Expr, ParserError> {
        let mut expr: Expr = self.logic()?;
        while let Some(operator) = self.match_token(&[
            TokenType::ClosingAngleBrack,
            TokenType::OpenAngleBrack,
            TokenType::GtEqual,
            TokenType::LtEqual,
            TokenType::TwoAnds,
            TokenType::TwoOrs,
        ]) {
            let right = self.logic()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    /// Logic And, logic Or.
    fn logic(&mut self) -> Result<Expr, ParserError> {
        let mut expr = self.term()?;
        while let Some(operator) = self.match_token(&[TokenType::And, TokenType::Or]) {
            let right = self.term()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    /// Additions and subtractions.
    fn term(&mut self) -> Result<Expr, ParserError> {
        let mut expr = self.factor()?;
        while let Some(operator) = self.match_token(&[TokenType::Plus, TokenType::Minus]) {
            let right = self.factor()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    /// Multiplications, divisions and reminder.
    fn factor(&mut self) -> Result<Expr, ParserError> {
        let mut expr = self.unary()?;
        while let Some(operator) =
            self.match_token(&[TokenType::Star, TokenType::Slash, TokenType::Percent])
        {
            let right = self.unary()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    /// Negate or invert.
    fn unary(&mut self) -> Result<Expr, ParserError> {
        if let Some(operator) = self.match_token(&[TokenType::Exclam, TokenType::Minus]) {
            let right = self.unary()?;
            return Ok(Expr::UnaryOp {
                op: operator,
                child: Box::new(right),
            });
        }
        return self.object();
    }

    //TODO: improve errors, things like "obj.String.foo()" or "obj.+.foo()" produces a generic "Couldn't parse a valid expression".
    /// Objects.
    fn object(&mut self) -> Result<Expr, ParserError> {
        let mut expr = self.call()?;
        let mut chain = vec![];
        loop {
            if let Expr::Call { .. } | Expr::Identifier(_) | Expr::Literal(_) = expr {
                if let Some(_) = self.match_token(&[TokenType::Dot]) {
                    // Is an object chain
                    chain.push(expr);
                    expr = self.call()?;
                } else {
                    if !chain.is_empty() {
                        // End of object chain
                        chain.push(expr);
                        expr = Expr::Object { chain }
                    }
                    break;
                }
            } else {
                if !chain.is_empty() {
                    return Err(ParserError {
                        message: "Object chain contains something that is not a call, identifier or literal".into(),
                        //TODO: get offset
                        offset: 0
                    });
                }
                break;
            }
        }
        Ok(expr)
    }

    /// Function calls.
    fn call(&mut self) -> Result<Expr, ParserError> {
        if let Some(func) = self.match_token(&[TokenType::Identifier]) {
            if let Some(_) = self.match_token(&[TokenType::OpenParenth]) {
                let mut args = vec![];
                let mut expect_next_arg = false;
                while self.match_token(&[TokenType::ClosingParenth]).is_none() {
                    if self.is_at_end() {
                        return Err(ParserError {
                            message: "Expecting a closing parenthesis for function call".into(),
                            offset: func.offset,
                        });
                    }
                    let expr = self.expression()?;
                    args.push(expr);
                    expect_next_arg = self.match_token(&[TokenType::Comma]).is_some();
                }
                if expect_next_arg {
                    return Err(ParserError {
                        message: "Expecting a missing argument for function".into(),
                        offset: func.offset,
                    });
                }
                Ok(Expr::Call { func, args })
            } else {
                Ok(Expr::Identifier(func))
            }
        } else {
            self.primary()
        }
    }

    /// Literals and groups of expressions in parenthesis.
    fn primary(&mut self) -> Result<Expr, ParserError> {
        if let Some(token) = self.match_token(&[
            TokenType::IntegerLiteral,
            TokenType::FloatLiteral,
            TokenType::BooleanLiteral,
            TokenType::StringLiteral,
            TokenType::RegexLiteral,
        ]) {
            let expr = Expr::Literal(token);
            return Ok(expr);
        }
        if let Some(token) = self.match_token(&[TokenType::OpenParenth]) {
            let expr = self.expression()?;
            if self.match_token(&[TokenType::ClosingParenth]).is_none() {
                return Err(ParserError {
                    message: "Expected ')' after expression.".into(),
                    offset: token.offset,
                });
            }
            let expr = Expr::Group {
                expr: Box::new(expr),
            };
            return Ok(expr);
        }
        if self.is_at_end() {
            Ok(Expr::Empty)
        } else {
            Err(ParserError {
                message: "Couldn't parse a valid expression.".into(),
                offset: self.tokens[0].offset,
            })
        }
    }

    fn match_token(&mut self, token_types: &[TokenType]) -> Option<Token> {
        if !self.is_at_end() {
            let first_token_type = self.tokens[0].token_type;
            if let Some(_) = token_types
                .iter()
                .find(|&&token_type| token_type == first_token_type)
            {
                // Unwrapping because we know for sure there is something in self.tokens
                return Some(self.tokens.pop_front().unwrap());
            }
        }
        None
    }

    fn is_at_end(&self) -> bool {
        self.tokens.len() == 0
    }
}
