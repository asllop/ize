//! # IZE Parser
//!
//! This module contains all the types and methods necessary to convert the list of tokens generated by the [lexer][crate::lexer] into an Abstract Syntax Tree.

use crate::lexer::{Line, Position, Token, TokenType};
use alloc::{boxed::Box, collections::VecDeque, string::String, vec::Vec};
use core::fmt::Display;

#[derive(Debug)]
/// Parsing error.
pub struct ParserError {
    /// Error message.
    pub message: String,
    /// Offset within the line where the error happened.
    pub offset: usize,
}

//TODO: create an AST struct with a Vec<Expr>, and use indexes to this vec instead of Box<Expr> to reduce allocations.

#[derive(Debug)]
/// Expression, it represents a node of the AST.
pub enum Expr {
    Literal(Token),
    Identifier(Token),
    Group {
        expr: Box<Expr>,
    },
    UnaryOp {
        op: Token,
        child: Box<Expr>,
    },
    BinaryOp {
        op: Token,
        left_child: Box<Expr>,
        right_child: Box<Expr>,
    },
    Call {
        func: Token,
        args: Vec<Expr>,
    },
    Empty,
}

impl Display for Expr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Expr::Literal(t) => write!(f, "{}{}", t.token_type, t.data),
            Expr::Identifier(t) => write!(f, "{}{}", t.token_type, t.data),
            Expr::Group { expr } => write!(f, "[{}]", expr),
            Expr::UnaryOp { op, child } => write!(f, "({} {})", op.token_type, child),
            Expr::BinaryOp {
                op,
                left_child,
                right_child,
            } => write!(f, "({} {} , {})", op.token_type, left_child, right_child),
            Expr::Call { func, args } => {
                write!(f, "{}(", func.data).ok();
                for arg in args {
                    write!(f, "{},", arg).ok();
                }
                write!(f, ")")
            }
            Expr::Empty => write!(f, ""),
        }
    }
}

#[derive(Debug)]
/// Parser for one line of code.
pub struct LineParser {
    pub tokens: VecDeque<Token>,
    pub position: Position,
}

impl LineParser {
    /// Parse line of code.
    pub fn parse(line: Line) -> Result<Expr, ParserError> {
        let mut parser = Self {
            tokens: line.tokens.into(),
            position: line.position,
        };
        let expr = parser.expression()?;
        if parser.is_at_end() {
            Ok(expr)
        } else {
            Err(ParserError {
                message: "Couldn't parse a complete expression".into(),
                offset: 0,
            })
        }
    }

    /// Any expression.
    fn expression(&mut self) -> Result<Expr, ParserError> {
        self.equality()
    }

    /// Equal and not equal.
    fn equality(&mut self) -> Result<Expr, ParserError> {
        let mut expr: Expr = self.comparison()?;
        while let Some(operator) = self.match_token(&[TokenType::TwoEquals, TokenType::NotEqual]) {
            let right = self.comparison()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    // Greather than, Lesser than, Gt or Equal, Lt or Equal, And, Or.
    fn comparison(&mut self) -> Result<Expr, ParserError> {
        let mut expr: Expr = self.logic()?;
        while let Some(operator) = self.match_token(&[
            TokenType::ClosingAngleBrack,
            TokenType::OpenAngleBrack,
            TokenType::GtEqual,
            TokenType::LtEqual,
            TokenType::TwoAnds,
            TokenType::TwoOrs,
        ]) {
            let right = self.logic()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    /// Logic And, logic Or.
    fn logic(&mut self) -> Result<Expr, ParserError> {
        let mut expr = self.term()?;
        while let Some(operator) = self.match_token(&[TokenType::And, TokenType::Or]) {
            let right = self.term()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    /// Additions and subtractions.
    fn term(&mut self) -> Result<Expr, ParserError> {
        let mut expr = self.factor()?;
        while let Some(operator) = self.match_token(&[TokenType::Plus, TokenType::Minus]) {
            let right = self.factor()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    /// Multiplications, divisions and reminder.
    fn factor(&mut self) -> Result<Expr, ParserError> {
        let mut expr = self.unary()?;
        while let Some(operator) =
            self.match_token(&[TokenType::Star, TokenType::Slash, TokenType::Percent])
        {
            let right = self.unary()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    /// Negate or invert.
    fn unary(&mut self) -> Result<Expr, ParserError> {
        if let Some(operator) = self.match_token(&[TokenType::Exclam, TokenType::Minus]) {
            let right = self.unary()?;
            return Ok(Expr::UnaryOp {
                op: operator,
                child: Box::new(right),
            });
        }
        return self.object();
    }

    /// Objects.
    fn object(&mut self) -> Result<Expr, ParserError> {
        let mut expr = self.call()?;
        while let Some(operator) = self.match_token(&[TokenType::Dot]) {
            let right = self.call()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    /// Function calls.
    fn call(&mut self) -> Result<Expr, ParserError> {
        if let Some(func) = self.match_token(&[TokenType::Identifier]) {
            if let Some(_) = self.match_token(&[TokenType::OpenParenth]) {
                let mut args = vec![];
                let mut expect_next_arg = false;
                while self.match_token(&[TokenType::ClosingParenth]).is_none() {
                    if self.is_at_end() {
                        return Err(ParserError {
                            message: "Expecting a closing parenthesis for function call".into(),
                            offset: func.offset,
                        });
                    }
                    let expr = self.expression()?;
                    args.push(expr);
                    expect_next_arg = self.match_token(&[TokenType::Comma]).is_some();
                }
                if expect_next_arg {
                    return Err(ParserError {
                        message: "Expecting a missing argument for function".into(),
                        offset: func.offset,
                    });
                }
                Ok(Expr::Call { func, args })
            } else {
                Ok(Expr::Identifier(func))
            }
        } else {
            self.primary()
        }
    }

    /// Literals, variables, and groups of expressions in parenthesis.
    fn primary(&mut self) -> Result<Expr, ParserError> {
        if let Some(token) = self.match_token(&[
            TokenType::IntegerLiteral,
            TokenType::FloatLiteral,
            TokenType::BooleanLiteral,
            TokenType::StringLiteral,
            TokenType::RegexLiteral,
        ]) {
            let expr = Expr::Literal(token);
            return Ok(expr);
        } else if let Some(token) = self.match_token(&[TokenType::Identifier]) {
            let expr = Expr::Identifier(token);
            return Ok(expr);
        }
        if let Some(token) = self.match_token(&[TokenType::OpenParenth]) {
            let expr = self.expression()?;
            if self.match_token(&[TokenType::ClosingParenth]).is_none() {
                return Err(ParserError {
                    message: "Expected ')' after expression.".into(),
                    offset: token.offset,
                });
            }
            let expr = Expr::Group {
                expr: Box::new(expr),
            };
            return Ok(expr);
        }
        if self.is_at_end() {
            Ok(Expr::Empty)
        } else {
            Err(ParserError {
                message: "Couldn't parse a valid expression.".into(),
                offset: self.tokens[0].offset,
            })
        }
    }

    fn match_token(&mut self, token_types: &[TokenType]) -> Option<Token> {
        if !self.is_at_end() {
            let first_token_type = self.tokens[0].token_type;
            if let Some(_) = token_types
                .iter()
                .find(|&&token_type| token_type == first_token_type)
            {
                // Unwrapping because we know for sure there is something in self.tokens
                return Some(self.tokens.pop_front().unwrap());
            }
        }
        None
    }

    fn is_at_end(&self) -> bool {
        self.tokens.len() == 0
    }
}
