//! # IZE Parser
//!
//! This module contains all the types and methods necessary to convert the tokens generated by the [lexer][crate::lexer] into an AST.

use crate::lexer::{Line, Position, Token, TokenType};
use alloc::{boxed::Box, collections::VecDeque, string::String};

#[derive(Debug)]
/// Lexical analysis error.
pub struct ParserError {
    /// Error message.
    pub message: String,
    /// Line where the error happened.
    pub line: usize,
    /// Offset within the line where the error happened.
    pub offset: usize,
}

#[derive(Debug)]
pub enum Expr {
    Terminal(Token),
    Group {
        expression: Box<Expr>,
    },
    UnaryOp {
        op: Token,
        child: Box<Expr>,
    },
    BinaryOp {
        op: Token,
        left_child: Box<Expr>,
        right_child: Box<Expr>,
    },
    Empty,
}

#[derive(Debug)]
pub struct LineParser {
    pub tokens: VecDeque<Token>,
    pub position: Position,
}

impl LineParser {
    /// Parse line of code.
    pub fn parse(line: Line) -> Result<Expr, ParserError> {
        let mut parser = Self {
            tokens: line.tokens.into(),
            position: line.position,
        };
        let expr = parser.expression()?;
        Ok(expr)
    }

    /// Any expression.
    fn expression(&mut self) -> Result<Expr, ParserError> {
        self.equality()
    }

    /// Equal and not equal.
    fn equality(&mut self) -> Result<Expr, ParserError> {
        let mut expr: Expr = self.term()?;
        while let Some(operator) = self.match_token(&[TokenType::TwoEquals, TokenType::NotEqual]) {
            let right = self.term()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    //TODO: comparison parsing

    /// Additions and subtractions.
    fn term(&mut self) -> Result<Expr, ParserError> {
        let mut expr = self.factor()?;
        while let Some(operator) = self.match_token(&[TokenType::Plus, TokenType::Minus]) {
            let right = self.factor()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    /// Multiplications, divisions and reminder.
    fn factor(&mut self) -> Result<Expr, ParserError> {
        let mut expr = self.primary()?;
        while let Some(operator) =
            self.match_token(&[TokenType::Star, TokenType::Slash, TokenType::Percent])
        {
            let right = self.primary()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    //TODO: unary parsing

    /// Literals and groups of expressions in parenthesis.
    fn primary(&mut self) -> Result<Expr, ParserError> {
        if let Some(token) = self.match_token(&[
            TokenType::IntegerLiteral,
            TokenType::FloatLiteral,
            TokenType::BooleanLiteral,
            TokenType::StringLiteral,
            TokenType::RegexLiteral,
        ]) {
            let expr = Expr::Terminal(token);
            return Ok(expr);
        }
        if let Some(token) = self.match_token(&[TokenType::OpenParenth]) {
            let expr = self.expression()?;
            if self.match_token(&[TokenType::ClosingParenth]).is_none() {
                return Err(ParserError {
                    message: "Expected ')' after expression.".into(),
                    line: self.position.line_num,
                    offset: token.offset,
                });
            }
            let expr = Expr::Group {
                expression: Box::new(expr),
            };
            return Ok(expr);
        }
        if self.is_at_end() {
            Ok(Expr::Empty)
        } else {
            Err(ParserError {
                message: "Couldn't parse a valid 'primary'.".into(),
                line: self.position.line_num,
                offset: 0,
            })
        }
    }

    fn match_token(&mut self, token_types: &[TokenType]) -> Option<Token> {
        if !self.is_at_end() {
            for token_type in token_types {
                if self.tokens[0].token_type == *token_type {
                    return Some(self.tokens.pop_front().unwrap());
                }
            }
        }
        None
    }

    fn is_at_end(&self) -> bool {
        self.tokens.len() == 0
    }
}
