//! # IZE Parser
//!
//! This module contains all the types and methods necessary to convert the list of tokens generated by the [lexer][crate::lexer] into an Abstract Syntax Tree.

use crate::lexer::{Line, Position, Token, TokenType};
use alloc::{boxed::Box, collections::VecDeque, string::String};
use core::fmt::Display;

#[derive(Debug)]
/// Parsing error.
pub struct ParserError {
    /// Error message.
    pub message: String,
    /// Offset within the line where the error happened.
    pub offset: usize,
}

//TODO: create an AST struct with a Vec<Expr>, and use indexes to this vec instead of Box<Expr> to reduce allocations.

#[derive(Debug)]
/// Expression, it represents a node of the AST.
pub enum Expr {
    Terminal(Token),
    Group {
        expression: Box<Expr>,
    },
    UnaryOp {
        op: Token,
        child: Box<Expr>,
    },
    BinaryOp {
        op: Token,
        left_child: Box<Expr>,
        right_child: Box<Expr>,
    },
    Empty,
}

impl Display for Expr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Expr::Terminal(t) => write!(f, "{}{}", t.token_type, t.data),
            Expr::Group { expression } => {
                write!(f, "[").unwrap_or_default();
                write!(f, "{}", expression).unwrap_or_default();
                write!(f, "]")
            }
            Expr::UnaryOp { op, child } => {
                write!(f, "({} ", op.token_type).unwrap_or_default();
                write!(f, "{}", child).unwrap_or_default();
                write!(f, ")")
            }
            Expr::BinaryOp {
                op,
                left_child,
                right_child,
            } => {
                write!(f, "({} ", op.token_type).unwrap_or_default();
                write!(f, "{} , {}", left_child, right_child).unwrap_or_default();
                write!(f, ")")
            }
            Expr::Empty => write!(f, ""),
        }
    }
}

#[derive(Debug)]
/// Parser for one line of code.
pub struct LineParser {
    pub tokens: VecDeque<Token>,
    pub position: Position,
}

impl LineParser {
    /// Parse line of code.
    pub fn parse(line: Line) -> Result<Expr, ParserError> {
        let mut parser = Self {
            tokens: line.tokens.into(),
            position: line.position,
        };
        let expr = parser.expression()?;
        if parser.is_at_end() {
            Ok(expr)
        } else {
            Err(ParserError {
                message: "Couldn't parse a complete expression".into(),
                offset: 0,
            })
        }
    }

    /// Any expression.
    fn expression(&mut self) -> Result<Expr, ParserError> {
        self.equality()
    }

    /// Equal and not equal.
    fn equality(&mut self) -> Result<Expr, ParserError> {
        let mut expr: Expr = self.comparison()?;
        while let Some(operator) = self.match_token(&[TokenType::TwoEquals, TokenType::NotEqual]) {
            let right = self.comparison()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    // Greather than, Litle than, Gt or Equal, Lt or Equal.
    fn comparison(&mut self) -> Result<Expr, ParserError> {
        let mut expr: Expr = self.term()?;
        while let Some(operator) = self.match_token(&[TokenType::TwoEquals, TokenType::NotEqual]) {
            let right = self.term()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    /// Additions and subtractions.
    fn term(&mut self) -> Result<Expr, ParserError> {
        let mut expr = self.factor()?;
        while let Some(operator) = self.match_token(&[TokenType::Plus, TokenType::Minus]) {
            let right = self.factor()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    /// Multiplications, divisions and reminder.
    fn factor(&mut self) -> Result<Expr, ParserError> {
        let mut expr = self.unary()?;
        while let Some(operator) =
            self.match_token(&[TokenType::Star, TokenType::Slash, TokenType::Percent])
        {
            let right = self.unary()?;
            expr = Expr::BinaryOp {
                op: operator,
                left_child: Box::new(expr),
                right_child: Box::new(right),
            };
        }
        Ok(expr)
    }

    /// Negate or invert.
    fn unary(&mut self) -> Result<Expr, ParserError> {
        if let Some(operator) = self.match_token(&[TokenType::Exclam, TokenType::Minus]) {
            let right = self.unary()?;
            return Ok(Expr::UnaryOp {
                op: operator,
                child: Box::new(right),
            });
        }
        return self.primary();
    }

    /// Literals and groups of expressions in parenthesis.
    fn primary(&mut self) -> Result<Expr, ParserError> {
        if let Some(token) = self.match_token(&[
            TokenType::IntegerLiteral,
            TokenType::FloatLiteral,
            TokenType::BooleanLiteral,
            TokenType::StringLiteral,
            TokenType::RegexLiteral,
        ]) {
            let expr = Expr::Terminal(token);
            return Ok(expr);
        }
        if let Some(token) = self.match_token(&[TokenType::OpenParenth]) {
            let expr = self.expression()?;
            if self.match_token(&[TokenType::ClosingParenth]).is_none() {
                return Err(ParserError {
                    message: "Expected ')' after expression.".into(),
                    offset: token.offset,
                });
            }
            let expr = Expr::Group {
                expression: Box::new(expr),
            };
            return Ok(expr);
        }
        if self.is_at_end() {
            Ok(Expr::Empty)
        } else {
            Err(ParserError {
                message: "Couldn't parse a valid 'primary'.".into(),
                offset: 0,
            })
        }
    }

    fn match_token(&mut self, token_types: &[TokenType]) -> Option<Token> {
        if !self.is_at_end() {
            for token_type in token_types {
                if self.tokens[0].token_type == *token_type {
                    // Unwrapping because we know for sure there is something in self.tokens
                    return Some(self.tokens.pop_front().unwrap());
                }
            }
        }
        None
    }

    fn is_at_end(&self) -> bool {
        self.tokens.len() == 0
    }
}
