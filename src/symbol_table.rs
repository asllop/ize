//! # Symbol Table

use alloc::{string::String, vec::Vec};
use rustc_hash::{FxHashMap, FxHashSet};

use crate::{err::IzeErr, pos::RangePos};

#[derive(Debug, Default)]
/// Symbol Table, associate each identifier in the code with a [Symbol] object.
pub struct SymbolTable {
    symbols: FxHashMap<String, Symbol>,
}

impl SymbolTable {
    /// Check if identifier is present in the ST and and is a model.
    pub fn contains_model(&self, id: &str) -> bool {
        if self.symbols.contains_key(id) {
            if let SymbolData::Model(_) = self.symbols[id].data {
                true
            } else {
                false
            }
        } else {
            false
        }
    }

    /// Insert symbol in the ST.
    pub fn insert(&mut self, key: String, value: Symbol, pos: RangePos) -> Result<(), IzeErr> {
        if !self.symbols.contains_key(key.as_str()) {
            self.symbols.insert(key, value);
            Ok(())
        } else {
            Err(IzeErr::new(format!("Symbol already exist: {}", key), pos))
        }
    }
}

#[derive(Debug)]
/// Symbol.
pub struct Symbol {
    /// Is imported symbol.
    pub is_imported: IsImported,
    /// Symbol metadata.
    pub data: SymbolData,
}

#[derive(Debug)]
/// Symbol is generated by an import, and is defined in another AST.
pub enum IsImported {
    No,
    Yes {
        /// Real symbol name, if not renamed will be the same that apears in the symbol table.
        real_sym: String,
    },
}

impl Symbol {
    /// New Symbol.
    pub fn new(is_imported: IsImported, data: SymbolData) -> Self {
        Self { is_imported, data }
    }

    /// Default model.
    pub fn new_imported(real_sym: String, data: SymbolData) -> Self {
        Self {
            is_imported: IsImported::Yes { real_sym },
            data,
        }
    }

    /// Default model.
    pub fn default_model() -> Self {
        Self {
            is_imported: IsImported::No,
            data: SymbolData::Model(Default::default()),
        }
    }

    /// Default transfer.
    pub fn default_transfer() -> Self {
        Self {
            is_imported: IsImported::No,
            data: SymbolData::Transfer(Default::default()),
        }
    }

    /// Default const.
    pub fn default_const() -> Self {
        Self {
            is_imported: IsImported::No,
            data: SymbolData::Const(Default::default()),
        }
    }

    /// Default pipe.
    pub fn default_pipe() -> Self {
        Self {
            is_imported: IsImported::No,
            data: SymbolData::Pipe(Default::default()),
        }
    }
}

#[derive(Debug)]
/// Symbol metadata.
pub enum SymbolData {
    Model(ModelMetadata),
    Transfer(TransferMetadata),
    Const(ConstMetadata),
    Pipe(PipeMetadata),
}

impl SymbolData {
    /// New constant symbol metadata.
    pub fn new_const(const_type: Type) -> Self {
        Self::Const(ConstMetadata::Data { const_type })
    }
}

/// Model metadata.
#[derive(Debug, Default)]
pub enum ModelMetadata {
    #[default]
    Uninit,
    Data {
        //TODO: add metadata
    },
}

/// Transfer metadata.
#[derive(Debug, Default)]
pub enum TransferMetadata {
    #[default]
    Uninit,
    Data {
        //TODO: add metadata
    },
}

/// Const metadata.
#[derive(Debug, Default)]
pub enum ConstMetadata {
    #[default]
    Uninit,
    Data {
        const_type: Type,
    },
}

/// Pipe metadata.
#[derive(Debug, Default)]
pub enum PipeMetadata {
    #[default]
    Uninit,
    Data {
        //TODO: add metadata
    },
}

#[derive(Debug, Eq, Hash)]
/// Type representation.
pub struct Type {
    pub ident: String,
    pub subtypes: Vec<Type>,
}

impl Type {
    /// New Type.
    pub fn new(ident: String, subtypes: Vec<Type>) -> Self {
        Type { ident, subtypes }
    }
}

// Custom PartialEq: in the case of a Mux, types can be in different orders: Mux[Int,Str] == Mux[Str,Int]
impl PartialEq for Type {
    fn eq(&self, other: &Self) -> bool {
        if self.ident == other.ident {
            let mut self_subtype_set = FxHashSet::default();
            for subtype in &self.subtypes {
                self_subtype_set.insert(subtype);
            }
            let mut other_subtype_set = FxHashSet::default();
            for subtype in &other.subtypes {
                other_subtype_set.insert(subtype);
            }
            self.subtypes == other.subtypes
        } else {
            false
        }
    }
}

pub const STR_TYPE: &str = "Str";
pub const INT_TYPE: &str = "Int";
pub const FLOAT_TYPE: &str = "Float";
pub const BOOL_TYPE: &str = "Bool";
pub const NONE_TYPE: &str = "None";
pub const NULL_TYPE: &str = "Null";
pub const ANY_TYPE: &str = "Any";

pub const MAP_TYPE: &str = "Map";
pub const LIST_TYPE: &str = "List";
pub const MUX_TYPE: &str = "Mux";
pub const TUPLE_TYPE: &str = "Tuple";
pub const TRAF_TYPE: &str = "Traf";
pub const REST_MARKER: &str = "...";
