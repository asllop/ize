//! # Symbol Table

use alloc::{string::String, vec::Vec};
use rustc_hash::FxHashMap;

use crate::{
    err::IzeErr,
    pos::RangePos,
};

#[derive(Debug, Default)]
/// Symbol Table, associate each identifier in the code with metadata.
pub struct SymbolTable {
    symbols: FxHashMap<String, SymbolMetadata>,
}

impl SymbolTable {
    /// Check if identifier is present in the ST and and is a model.
    pub fn contains_model(&self, id: &str) -> bool {
        if self.symbols.contains_key(id) {
            if let SymbolKind::Model() = self.symbols[id].kind {
                true
            } else {
                false
            }
        } else {
            false
        }
    }

    /// Insert symbol in the ST.
    pub fn insert(
        &mut self,
        key: String,
        value: SymbolMetadata,
        pos: RangePos,
    ) -> Result<(), IzeErr> {
        if !self.symbols.contains_key(key.as_str()) {
            self.symbols.insert(key, value);
            Ok(())
        } else {
            Err(IzeErr::new(format!("Symbol already exist: {}", key), pos))
        }
    }
}

#[derive(Debug)]
/// Symbol metadata.
pub struct SymbolMetadata {
    /// Is imported symbol.
    pub is_imported: IsImported,
    /// Command kind that defined this symbol.
    pub kind: SymbolKind,
}

#[derive(Debug)]
/// Symbol is generated by an import, and is defined in another AST.
pub enum IsImported {
    No,
    Yes {
        /// Real symbol name, if not renamed will be the same that apears in the symbol table.
        real_sym: String,
    },
}

impl SymbolMetadata {
    /// New SymbolMetadata.
    pub fn new(is_imported: IsImported, kind: SymbolKind) -> Self {
        Self { is_imported, kind }
    }

    /// Default model.
    pub fn default_model() -> Self {
        Self {
            is_imported: IsImported::No,
            kind: SymbolKind::Model(),
        }
    }

    /// Default transfer.
    pub fn default_transfer() -> Self {
        Self {
            is_imported: IsImported::No,
            kind: SymbolKind::Transfer(),
        }
    }

    /// Default const.
    pub fn default_const() -> Self {
        Self {
            is_imported: IsImported::No,
            kind: SymbolKind::Const(),
        }
    }

    /// Default pipe.
    pub fn default_pipe() -> Self {
        Self {
            is_imported: IsImported::No,
            kind: SymbolKind::Pipe(),
        }
    }
}

#[derive(Debug)]
/// Symbol kind. TODO: add metadata to variants.
//TODO: more metadata specific to the command, or ref to command or to the imported AST that contains the symbol
pub enum SymbolKind {
    Model(),
    Transfer(),
    Const(),
    Pipe(),
}

#[derive(Debug, PartialEq)]
/// Type representation.
pub struct Type {
    pub ident: String,
    pub subtypes: Vec<Type>,
}

impl Type {
    /// New Type.
    pub fn new(ident: String, subtypes: Vec<Type>) -> Self {
        Type { ident, subtypes }
    }
}

pub const STR_TYPE: &str = "Str";
pub const INT_TYPE: &str = "Int";
pub const FLOAT_TYPE: &str = "Float";
pub const BOOL_TYPE: &str = "Bool";
pub const NONE_TYPE: &str = "None";
pub const NULL_TYPE: &str = "Null";
pub const ANY_TYPE: &str = "Any";

pub const MAP_TYPE: &str = "Map";
pub const LIST_TYPE: &str = "List";
pub const MUX_TYPE: &str = "Mux";
pub const TUPLE_TYPE: &str = "Tuple";
pub const TRAF_TYPE: &str = "Traf";
pub const OTHER_TYPE: &str = "...";